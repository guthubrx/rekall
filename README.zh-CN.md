# Rekall

```
        ██████╗ ███████╗██╗  ██╗ █████╗ ██╗     ██╗
        ██╔══██╗██╔════╝██║ ██╔╝██╔══██╗██║     ██║
        ██████╔╝█████╗  █████╔╝ ███████║██║     ██║
        ██╔══██╗██╔══╝  ██╔═██╗ ██╔══██║██║     ██║
        ██║  ██║███████╗██║  ██╗██║  ██║███████╗███████╗
        ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚══════╝
```

> *"Get your ass to Mars. Quaid... crush those bugs"*

**翻译：** [English](README.md) | [Français](README.fr.md) | [Español](README.es.md) | [Deutsch](README.de.md)

---

## 你已经解决过这个问题了。

三个月前，你花了两个小时调试一个神秘的错误。你找到了解决方案。然后继续前进。

今天，同样的错误出现了。你盯着它看。它看起来很熟悉。但那个解决方案在哪里？

你从头开始。又浪费了两个小时。

**每个开发者都会遇到这种情况。** 根据研究，财富500强公司每年损失315亿美元，因为学到的经验从未被记录下来。不是因为疏忽——而是因为我们是人类，人类会遗忘。

---

## 如果你的AI助手能替你记住呢？

想象一下：你让Claude或Cursor修复一个bug。在写任何代码之前，它先检查你的个人知识库：

```
🔍 搜索你的知识...

找到2个相关条目：

[1] bug: Safari上的CORS错误 (85%匹配)
    "添加 credentials: include 和正确的 Access-Control 头"
    → 你3个月前解决过这个

[2] pattern: 跨域请求处理 (72%匹配)
    "总是在Safari上测试 - 它对CORS更严格"
    → 从4个类似bug中提取的模式
```

你的AI助手现在有了上下文。它知道什么以前有效。它不会重新发明轮子——它会在你过去的经验上构建。

**这就是Rekall。**

---

## 一个像你一样思考的第二大脑

Rekall不仅仅是一个笔记应用。它基于人类记忆实际运作的方式构建：

### 你的知识，相互连接

当你解决某件事时，相关知识会自动浮现。修复了一个超时bug？Rekall会向你展示你解决过的另外三个超时问题，以及你从中提取的重试模式。

```
              ┌──────────────┐
              │  Auth超时    │
              │   (今天)     │
              └──────┬───────┘
                     │ 类似于...
        ┌────────────┼────────────┐
        ▼            ▼            ▼
  ┌──────────┐ ┌──────────┐ ┌──────────┐
  │ DB #47   │ │ API #52  │ │ Cache #61│
  │ (2周前)  │ │ (1个月前)│ │ (3个月前)│
  └────┬─────┘ └────┬─────┘ └──────────┘
       └──────┬─────┘
              ▼
     ┌─────────────────┐
     │ 模式：带回退    │
     │ 的重试          │
     └─────────────────┘
```

### 事件变成智慧

你修复的每个bug都是一个**情节**——一个有上下文的特定事件。但模式会出现。在修复三个类似的超时bug后，Rekall帮助你提取**原则**："外部API总是添加指数回退重试。"

情节是原材料。模式是可重用的知识。

### 被遗忘的知识重新浮现

Rekall追踪你访问什么以及何时访问。几个月没碰过的知识？它会在完全消失之前提醒你。把它想象成给你的开发者大脑的间隔重复。

---

## 实际操作

### 1. 工作时捕获知识

解决了棘手的问题后，用10秒钟记录下来：

```bash
rekall add bug "Safari上CORS失败" --context-interactive
```

Rekall会问：*发生了什么？什么修复了它？什么关键词应该触发这个？*

```
> 情况：Safari即使设置了CORS头也阻止请求
> 解决方案：添加 credentials: 'include' 和显式 Allow-Origin
> 关键词：cors, safari, cross-origin, fetch, credentials
```

完成。未来的你会感谢你。

### 2. 按意义搜索，不只是关键词

不记得你是叫它"CORS"还是"跨域"了？没关系。

```bash
rekall search "浏览器阻止我的API调用"
```

Rekall理解意义。即使你的词不完全匹配，它也能找到相关条目。

### 3. 让你的AI助手使用它

将Rekall连接到Claude、Cursor或任何支持MCP的AI：

```bash
rekall mcp  # 启动服务器
```

现在你的AI在每次修复前都会查阅你的知识。它引用你过去的解决方案。它建议保存新的。你的知识随时间积累。

---

## 界面

### 终端UI
```bash
rekall  # 启动可视界面
```

```
┌─ Rekall ────────────────────────────────────────────────┐
│  🔍 搜索: cors safari                                   │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  [1] bug: Safari上CORS失败                 85% ██████   │
│      safari, cors, fetch  •  3个月前                    │
│      "添加 credentials: include..."                     │
│                                                         │
│  [2] pattern: 跨域处理                     72% █████    │
│      架构  •  1个月前                                   │
│      "Safari对CORS更严格"                               │
│                                                         │
├─────────────────────────────────────────────────────────┤
│  [/] 搜索  [a] 添加  [Enter] 查看  [q] 退出             │
└─────────────────────────────────────────────────────────┘
```

---

## 你可以捕获什么？

| 类型 | 用于 | 示例 |
|------|------|------|
| `bug` | 解决的问题 | "Safari CORS与credentials" |
| `pattern` | 可重用的方法 | "带指数回退的重试" |
| `decision` | 为什么选X而不是Y | "这个项目用PostgreSQL而不是MongoDB" |
| `pitfall` | 要避免的错误 | "生产环境永远不要SELECT *" |
| `config` | 有效的配置 | "VS Code Python调试配置" |
| `reference` | 有用的文档/链接 | "那个StackOverflow答案" |
| `snippet` | 值得保留的代码 | "通用防抖函数" |
| `til` | 快速学习 | "Git rebase -i可以重新排序提交" |

---

## 100%本地。100%属于你。

```
你的机器
     │
     ▼
┌─────────────────────────────────────┐
│  ~/.local/share/rekall/             │
│                                     │
│  一切都留在这里。                    │
│  没有云。没有账户。没有追踪。        │
│                                     │
└─────────────────────────────────────┘
     │
     ▼
  不会去别的地方。永远不会。
```

你的知识属于你。Rekall不会打电话回家。它不需要账户。它可以离线工作。你的调试历史、你的架构决策、你辛苦获得的智慧——全部私密，全部本地。

---

## 开始使用

### 安装

```bash
# 使用 uv（推荐）
uv tool install git+https://github.com/guthubrx/rekall.git

# 使用 pipx
pipx install git+https://github.com/guthubrx/rekall.git
```

### 试试看

```bash
# 添加你的第一个条目
rekall add bug "我的第一个捕获的bug" -t test

# 搜索它
rekall search "第一个"

# 打开可视界面
rekall
```

### 连接你的AI助手

对于Claude Code、Cursor或任何MCP兼容工具：

```bash
rekall mcp  # 将Rekall暴露给你的AI
```

---

## 基于科学

Rekall不仅仅方便——它基于认知科学研究构建：

- **知识图谱**提高检索准确率20%
- **间隔重复**提高记忆保持率6-9%
- **情节记忆vs语义记忆**是你的大脑实际组织信息的方式
- **基于历史的故障定位**表明有过去bug的文件更可能有新bug

我们读了论文，所以你不必读。然后我们构建了一个应用它们的工具。

---

## 要求

- Python 3.9+
- 就这些。没有云服务。没有API密钥（除非你想要语义搜索）。没有账户。

---

## 许可证

MIT——随你怎么用。

---

<p align="center">
<strong>停止丢失知识。开始记忆。</strong>
<br><br>

```bash
uv tool install git+https://github.com/guthubrx/rekall.git
rekall
```
</p>
