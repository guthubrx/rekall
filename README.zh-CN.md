<div align="center">

<!-- LOGO: 当 logo.png 准备好后取消注释
<img src="docs/images/logo.png" alt="Rekall Logo" width="120">
-->

# Rekall

**你的开发者知识，即时召回。**

<p>
  <img src="https://img.shields.io/badge/100%25-本地-blue?style=flat-square" alt="100% 本地">
  <img src="https://img.shields.io/badge/无需_API_密钥-green?style=flat-square" alt="无需 API 密钥">
  <img src="https://img.shields.io/badge/MCP-兼容-purple?style=flat-square" alt="MCP 兼容">
  <img src="https://img.shields.io/badge/Python-3.9+-yellow?style=flat-square" alt="Python 3.9+">
</p>

*"Get your ass to Mars. Quaid... crush those bugs"*

[文档](#目录) · [安装](#开始使用) · [MCP 集成](#mcp-服务器适用于任何-ai-助手)

**翻译：** [English](README.md) | [Français](README.fr.md) | [Español](README.es.md) | [Deutsch](README.de.md)

</div>

---

## 目录

- [TL;DR](#tldr)
- [问题所在](#你已经解决过这个问题)
- [解决方案](#如果你的-ai-助手能为你记住呢)
- [实际使用](#如何在实践中工作)
- [界面](#界面)
- [自动化功能](#rekall-为你做什么)
- [条目类型](#可以捕获什么)
- [来源](#追踪你的来源)
- [隐私保护](#100-本地-100-属于你)
- [开始使用](#开始使用)
- [MCP 服务器](#mcp-服务器适用于任何-ai-助手)
- [Speckit 集成](#与-speckit-集成)
- [底层原理](#底层原理搜索如何工作) *(技术向)*
- [基于科学](#基于科学) *(研究向)*

---

### TL;DR

**问题所在：** 每个开发者都曾两次解决同一个 bug。不是因为粗心——而是因为人类会忘记。研究显示，财富 500 强公司每年因未捕获的知识损失 315 亿美元。

**我们的方法：** Rekall 是基于认知科学研究构建的个人知识库。我们研究了人类记忆的实际工作方式——情景记忆 vs 语义记忆、间隔重复、知识图谱——并将其应用到开发者工作流程中。

**功能：** 在工作时捕获 bug、模式、决策、配置。通过含义搜索，而不仅仅是关键词——Rekall 使用可选的本地嵌入模型（all-MiniLM-L6-v2）结合全文搜索，即使你的词汇不完全匹配也能找到相关条目。存储丰富的上下文（情况、解决方案、失败的尝试）以便稍后区分相似的问题。

**与你的工具协同：** Rekall 暴露了一个与大多数 AI 驱动的开发工具兼容的 MCP 服务器——Claude Code、Claude Desktop、Cursor、Windsurf、Continue.dev 以及任何兼容 MCP 的客户端。一条命令（`rekall mcp`），你的 AI 就会在每次修复前查阅你的知识。

**自动化内容：** 关键词提取、整合评分、模式检测、链接建议、复习调度（SM-2 间隔重复）。你专注于捕获——Rekall 处理其余部分。

```bash
# 安装
uv tool install git+https://github.com/guthubrx/rekall.git

# 捕获（交互模式会引导你）
rekall add bug "Safari 上 CORS 失败" --context-interactive

# 搜索（理解含义，不仅仅是关键词）
rekall search "浏览器阻止 API"

# 连接到 AI（一条命令，适用于 Claude/Cursor/Windsurf）
rekall mcp
```

---

<br>

## 你已经解决过这个问题。

三个月前，你花了两个小时调试一个神秘的错误。你找到了修复方法。然后继续前进。

今天，同样的错误又出现了。你盯着它看。看起来很熟悉。但那个解决方案在哪里呢？

你从头开始。又浪费了两个小时。

**这种情况发生在每个开发者身上。** 根据研究，财富 500 强公司每年因未捕获的经验教训损失 315 亿美元。不是因为人们粗心——而是因为我们是人，人类会忘记。

<br>

## 如果你的 AI 助手能为你记住呢？

想象一下：你让 Claude 或 Cursor 修复一个 bug。在编写任何一行代码之前，它检查你的个人知识库：

```
🔍 搜索你的知识...

找到 2 个相关条目：

[1] bug: Safari 上的 CORS 错误（85% 匹配）
    "添加 credentials: include 和正确的 Access-Control 头"
    → 你在 3 个月前解决过这个问题

[2] pattern: 跨域请求处理（72% 匹配）
    "始终在 Safari 上测试 - 它有更严格的 CORS 执行"
    → 从 4 个类似 bug 中提取的模式
```

你的 AI 助手现在有了上下文。它知道之前什么有效。它不会重新发明轮子——它会建立在你过去的经验之上。

**这就是 Rekall。**

<p align="center">
  <img src="docs/screenshots/demo.gif" alt="Rekall 实际操作" width="700">
</p>

<!--
截图占位符 - 将你的图片添加到 docs/screenshots/
选项：
- demo.gif: 展示工作流程的动画 GIF（推荐）
- tui.png: 终端 UI 截图
- search.png: 搜索结果
- mcp.png: 与 Claude/Cursor 的 MCP 集成
-->

<br>

## 像你一样思考的第二大脑

> **核心理念：** Rekall 基于人类记忆的实际工作方式构建——连接相关知识、从情景中提取模式，以及在信息消失前浮现被遗忘的信息。

Rekall 不仅仅是一个笔记应用。它基于人类记忆的实际工作方式构建：

### 你的知识，相互连接

当你解决某个问题时，相关知识会自动浮现。修复了一个超时 bug？Rekall 会向你展示你解决过的其他三个超时问题，以及你从中提取的重试模式。

```
              ┌──────────────┐
              │ Auth Timeout │
              │   (今天)     │
              └──────┬───────┘
                     │ 类似于...
        ┌────────────┼────────────┐
        ▼            ▼            ▼
  ┌──────────┐ ┌──────────┐ ┌──────────┐
  │ DB #47   │ │ API #52  │ │ Cache #61│
  │ (2 周前) │ │ (1 月前) │ │ (3 月前) │
  └────┬─────┘ └────┬─────┘ └──────────┘
       └──────┬─────┘
              ▼
     ┌─────────────────┐
     │ PATTERN: Retry  │
     │ with backoff    │
     └─────────────────┘
```

### 事件变成智慧

你修复的每个 bug 都是一个**情景**——一个有上下文的特定事件。但模式会浮现出来。在修复三个类似的超时 bug 后，Rekall 帮助你提取**原则**："对于外部 API 始终添加指数退避的重试。"

情景是原材料。模式是可重用的知识。

<br>

### 被遗忘的知识重新浮现

Rekall 跟踪你访问的内容和时间。几个月没碰过的知识？它会在完全消失之前提醒你。把它想象成你的开发大脑的间隔重复。

---

## 如何在实践中工作

### 1. 在工作时捕获知识

解决了一些棘手的问题后，在 10 秒内捕获它：

```bash
rekall add bug "Safari 上 CORS 失败" --context-interactive
```

Rekall 会问：*发生了什么？什么修复了它？什么关键词应该触发这个？*

```
> 情况：即使设置了 CORS 头，Safari 仍然阻止请求
> 解决方案：添加 credentials: 'include' 和显式的 Allow-Origin
> 关键词：cors, safari, cross-origin, fetch, credentials
```

完成。你未来的自己会感谢你。

### 2. 通过含义搜索，不仅仅是关键词

不记得你叫它"CORS"还是"跨域"？没关系。

```bash
rekall search "浏览器阻止我的 API 调用"
```

Rekall 理解含义。即使你的词汇不完全匹配，它也能找到相关条目。

### 3. 让你的 AI 助手使用它

将 Rekall 连接到 Claude、Cursor 或任何支持 MCP 的 AI：

```bash
rekall mcp  # 启动服务器
```

现在你的 AI 在每次修复前都会查阅你的知识。它会引用你过去的解决方案。它会建议保存新的解决方案。你的知识随时间复利增长。

---

## 界面

### 终端 UI
```bash
rekall  # 启动可视化界面
```

```
┌─ Rekall ────────────────────────────────────────────────┐
│  🔍 搜索: cors safari                                   │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  [1] bug: Safari 上 CORS 失败          85% ██████       │
│      safari, cors, fetch  •  3 个月前                   │
│      "添加 credentials: include..."                     │
│                                                         │
│  [2] pattern: 跨域处理                 72% █████        │
│      architecture  •  1 个月前                          │
│      "Safari 有更严格的 CORS 执行"                      │
│                                                         │
│  [3] reference: MDN CORS 指南          68% ████         │
│      docs, mdn  •  6 个月前                             │
│                                                         │
├─────────────────────────────────────────────────────────┤
│  [/] 搜索  [a] 添加  [Enter] 查看  [q] 退出             │
└─────────────────────────────────────────────────────────┘
```

### 命令行
```bash
rekall add bug "修复: auth 中的空指针" -t auth,null
rekall search "认证错误"
rekall show 01HX7...
rekall link 01HX7 01HY2 --type related
rekall review  # 间隔重复会话
```

<br>

## Rekall 为你做什么

> **理念：** 你专注于捕获知识。Rekall 处理其他一切。

### 每次添加条目时

- **关键词提取** — 分析你的标题和内容，建议相关关键词
- **上下文验证** — 如果情况/解决方案太模糊或泛泛而谈会发出警告
- **嵌入生成** — 为智能搜索创建语义向量（如果启用）
- **自动索引** — 实时更新全文搜索索引

### 每次搜索时

- **混合匹配** — 结合精确词汇（FTS5）+ 含义（嵌入）+ 触发器（关键词）
- **无需配置** — 开箱即用，无需调整
- **相关条目** — 自动显示链接的知识

### 在后台（你什么都不用做）

- **访问跟踪** — 每次查看都会更新频率和最近性统计
- **整合评分** — 计算每个记忆的"稳定"程度（60% 频率 + 40% 新鲜度）
- **模式检测** — 查找相似条目的集群，建议创建模式
- **链接建议** — 检测相关条目，提出连接
- **复习调度** — SM-2 算法计划最佳复习时间（间隔重复）
- **上下文压缩** — 以 70-85% 更小的大小存储详细上下文

### 运行 `rekall review` 时

- **加载到期条目** — 基于 SM-2 调度，而不是任意日期
- **调整难度** — 你的评分（0-5）自动更新难易因子
- **重新调度** — 计算下一个最佳复习日期

---

## 可以捕获什么？

| 类型 | 用途 | 示例 |
|------|-----|---------|
| `bug` | 你解决过的问题 | "Safari CORS with credentials" |
| `pattern` | 可重用的方法 | "带指数退避的重试" |
| `decision` | 为什么你选择 X 而不是 Y | "此项目选择 PostgreSQL 而非 MongoDB" |
| `pitfall` | 要避免的错误 | "在生产环境中永远不要使用 SELECT *" |
| `config` | 有效的设置 | "VS Code Python 调试配置" |
| `reference` | 有用的文档/链接 | "那个 StackOverflow 答案" |
| `snippet` | 值得保留的代码 | "通用防抖函数" |
| `til` | 快速学习 | "Git rebase -i 可以重新排序提交" |

---

## 追踪你的来源

> **理念：** 每一条知识都来自某个地方。Rekall 帮助你追踪*来源*——评估可靠性、重访原始来源，以及查看哪些来源对你最有价值。

### 将条目链接到来源

当你捕获知识时，可以附加来源：

```bash
# 添加一个带有 URL 来源的 bug
rekall add bug "Safari CORS fix" -t cors,safari
# 然后链接来源 URL
rekall source link 01HX7... --url "https://stackoverflow.com/q/12345"

# 或使用 TUI：打开条目 → 添加来源
rekall
```

### 三种来源类型

| 类型 | 用途 | 示例 |
|------|------|------|
| `url` | 网页、文档 | Stack Overflow、MDN、博客文章 |
| `theme` | 重复出现的主题或导师 | "与 Alice 的代码审查"、"架构会议" |
| `file` | 本地文档 | PDF、内部文档、笔记 |

### 可靠性评级（Admiralty 系统）

并非所有来源都同样可靠。Rekall 使用简化的 **Admiralty 系统**：

| 评级 | 含义 | 示例 |
|------|------|------|
| **A** | 高度可靠、权威 | 官方文档、同行评审、知名专家 |
| **B** | 通常可靠 | 知名博客、被接受的 SO 答案 |
| **C** | 可疑或未验证 | 随机论坛帖子、未经测试的建议 |

### 个人分数：对*你*重要的

每个来源都有一个**个人分数**（0-100），基于：

```
分数 = 使用频率 × 最近度 × 可靠性

- 使用频率：你多久引用这个来源
- 最近度：你最后一次使用的时间（随时间衰减）
- 可靠性：A=1.0, B=0.8, C=0.6
```

你频繁且最近使用的来源排名更高——无论它们在全局上多么"权威"。你的个人经验很重要。

### 反向链接：查看来源的所有条目

点击任何来源查看引用它的所有条目：

```
┌─ 来源: stackoverflow.com/questions/* ───────────────────┐
│  可靠性: B  │  分数: 85  │  使用: 12 次                  │
├─────────────────────────────────────────────────────────┤
│  引用此来源的条目：                                      │
│                                                         │
│  [1] bug: Safari 上 CORS 失败                           │
│  [2] bug: 慢速网络上的 Fetch 超时                       │
│  [3] pattern: API 调用的错误处理                        │
└─────────────────────────────────────────────────────────┘
```

### 链接失效检测

Web 来源可能会消失。Rekall 定期检查 URL 来源并标记无法访问的：

```bash
rekall sources --verify  # 验证所有来源
rekall sources --status inaccessible  # 列出失效链接
```

TUI 的来源仪表板显示：
- **顶级来源**按个人分数排序
- **新兴来源**（最近多次被引用）
- **休眠来源**（6 个月以上未使用）
- **无法访问的来源**（检测到链接失效）

---

## 100% 本地。100% 属于你。

```
你的机器
     │
     ▼
┌─────────────────────────────────────┐
│  ~/.local/share/rekall/             │
│                                     │
│  一切都留在这里。                   │
│  没有云。没有账户。没有跟踪。       │
│                                     │
└─────────────────────────────────────┘
     │
     ▼
  永远不会去其他地方。
```

你的知识属于你。Rekall 不会回传数据。不需要账户。离线工作。你的调试历史、架构决策、来之不易的智慧——全部私密、全部本地。

---

## 开始使用

### 安装

```bash
# 使用 uv（推荐）
uv tool install git+https://github.com/guthubrx/rekall.git

# 使用 pipx
pipx install git+https://github.com/guthubrx/rekall.git
```

### 试用

```bash
# 添加你的第一个条目
rekall add bug "我的第一个捕获的 bug" -t test

# 搜索它
rekall search "第一个"

# 打开可视化界面
rekall
```

---

## MCP 服务器：适用于任何 AI 助手

Rekall 通过 **Model Context Protocol (MCP)** 暴露你的知识库——这是将 AI 助手连接到外部工具的开放标准。

### 一条命令，通用访问

```bash
rekall mcp  # 启动 MCP 服务器
```

### 与主流 AI 工具兼容

| 工具 | 状态 | 配置 |
|------|--------|---------------|
| **Claude Code** | ✅ 原生 | 自动检测 |
| **Claude Desktop** | ✅ 原生 | 添加到 `claude_desktop_config.json` |
| **Cursor** | ✅ 支持 | MCP 设置 |
| **Windsurf** | ✅ 支持 | MCP 设置 |
| **Continue.dev** | ✅ 支持 | MCP 配置 |
| **任何 MCP 客户端** | ✅ 兼容 | 标准 MCP 协议 |

### 配置示例（Claude Desktop）

添加到你的 `claude_desktop_config.json`：

```json
{
  "mcpServers": {
    "rekall": {
      "command": "rekall",
      "args": ["mcp"]
    }
  }
}
```

### 你的 AI 可以做什么

连接后，你的 AI 助手可以：

- **搜索**你的知识库后再回答
- 在响应中**引用**你过去的解决方案
- 在解决问题后**建议**捕获新知识
- 自动**链接**相关条目
- **浮现**你调试历史中的模式

你的知识自动复利增长——使用得越多，它就越智能。

---

## 与 Speckit 集成

[Speckit](https://github.com/YOUR_USERNAME/speckit) 是一个规范驱动的开发工具包。与 Rekall 结合使用，创建了一个强大的工作流程，你的规范为你的知识库提供信息。

### 为什么集成？

- **规范成为可搜索的知识**：规范编写期间做出的决策被捕获
- **模式浮现**：跨项目的常见架构选择浮现出来
- **上下文保留**：规范背后的"为什么"永远不会丢失

### 设置

1. 安装两个工具：
```bash
uv tool install git+https://github.com/guthubrx/rekall.git
uv tool install git+https://github.com/YOUR_USERNAME/speckit.git
```

2. 配置 Speckit 使用 Rekall（在你的 `.speckit/config.yaml` 中）：
```yaml
integrations:
  rekall:
    enabled: true
    auto_capture: true  # 自动捕获决策
    types:
      - decision
      - pattern
      - pitfall
```

3. 在规范工作期间，Speckit 会：
   - 在 Rekall 中查询相关的过去决策
   - 建议捕获新的架构选择
   - 将规范链接到相关的知识条目

### 示例工作流程

```bash
# 开始指定一个功能
speckit specify "用户认证系统"

# Speckit 查询 Rekall："你之前做过认证决策吗？"
# → 显示你在另一个项目中过去的 OAuth vs JWT 决策

# 完成规范后
speckit plan

# Rekall 捕获：decision "微服务中的无状态认证使用 JWT"
```

<br>

<details>
<summary><h2>底层原理：搜索如何工作</h2></summary>

> **TL;DR：** 混合搜索结合 FTS5（50%）+ 语义嵌入（30%）+ 关键词（20%）。可选的本地模型，无需 API 密钥。

Rekall 不仅仅做关键词匹配。它理解你的意思。

### 简单搜索的问题

你捕获了一个关于"Safari 上 CORS 错误"的 bug。稍后，你搜索"浏览器阻止 API 调用"。简单的关键词搜索找不到任何东西——词汇不匹配。

### 混合搜索：全面且快速

Rekall 结合三种搜索策略：

```
┌──────────────────────────────────────────────────────────────┐
│                     你的查询                                  │
│              "浏览器阻止 API 调用"                            │
└──────────────────────────────────┬───────────────────────────┘
                                   │
           ┌───────────────────────┼───────────────────────┐
           ▼                       ▼                       ▼
    ┌─────────────┐        ┌─────────────┐        ┌─────────────┐
    │   FTS5      │        │  Semantic   │        │  Keywords   │
    │  (50%)      │        │   (30%)     │        │   (20%)     │
    │             │        │             │        │             │
    │ 精确词汇    │        │ 通过嵌入    │        │ 结构化      │
    │ 匹配        │        │ 理解含义    │        │ 触发器      │
    └──────┬──────┘        └──────┬──────┘        └──────┬──────┘
           │                      │                      │
           └───────────────────────┼───────────────────────┘
                                   ▼
                        ┌─────────────────┐
                        │  最终得分       │
                        │  85% 匹配       │
                        └─────────────────┘
```

- **全文搜索（50%）**：SQLite FTS5 查找精确和部分词汇匹配
- **语义搜索（30%）**：嵌入查找概念上相似的内容——"浏览器"匹配"Safari"，"阻止"匹配"CORS 错误"
- **关键词索引（20%）**：你的结构化上下文关键词提供显式触发器

### 本地嵌入：可选但强大

语义搜索是**可选的**。Rekall 仅使用 FTS5 全文搜索就能完美工作——无需模型。

但如果你想要语义理解，Rekall 使用 **all-MiniLM-L6-v2**（2300 万参数），这是一个完全在你的机器上运行的快速高效嵌入模型：

- **100% 本地**：没有数据离开你的计算机，没有 API 密钥，没有云
- **快速**：在标准笔记本 CPU 上每个嵌入约 50 毫秒
- **小巧**：约 100MB 内存占用
- **可配置**：通过配置切换到多语言模型（如 `paraphrase-multilingual-MiniLM-L12-v2`）

```bash
# 仅 FTS 模式（默认，无需模型）
rekall search "CORS 错误"

# 启用语义搜索（首次使用时下载模型）
rekall config set embeddings.enabled true
```

### 双重嵌入：上下文很重要

当你捕获知识时，Rekall 存储两个嵌入：

1. **摘要嵌入**：标题 + 内容 + 标签——用于聚焦搜索
2. **上下文嵌入**：完整的情况/解决方案——用于探索性搜索

这解决了检索中的一个基本问题：摘要会丢失上下文。如果你搜索"Safari 堆栈跟踪"，摘要"修复 CORS"不会匹配——但你捕获的完整上下文（其中提到了堆栈跟踪）会匹配。

### 结构化上下文：有效的消歧

你修复了 5 个不同的"超时" bug。以后如何找到正确的那个？仅靠关键词无济于事——它们都标记为"timeout"。

Rekall 为每个条目捕获**结构化上下文**：

```
┌─────────────────────────────────────────────────────────────┐
│  situation        │  "部署后 API 调用超时"                   │
│  solution         │  "增加连接池大小"                         │
│  what_failed      │  "重试逻辑没有帮助"                       │
│  trigger_keywords │  ["timeout", "deploy", "connection pool"]│
│  error_messages   │  "ETIMEDOUT after 30s"                  │
│  files_modified   │  ["config/database.yml"]                │
└─────────────────────────────────────────────────────────────┘
```

当你搜索时，Rekall 使用此上下文来消歧：

- **"部署后超时"** → 找到连接池 bug（匹配情况）
- **"ETIMEDOUT"** → 找到带有该确切错误消息的条目
- **"重试不起作用"** → 找到尝试重试但失败的条目

`--context-interactive` 标志会引导你捕获这些内容：

```bash
rekall add bug "生产环境中的超时" --context-interactive
# Rekall 会问：发生了什么？什么修复了它？什么不起作用？
# 你的答案成为可搜索的消歧上下文
```

### 压缩存储

上下文可能很冗长。Rekall 使用 zlib 压缩结构化上下文，并维护一个单独的关键词索引以进行快速搜索：

```
┌─────────────────────────────────────────────────────────────┐
│                    条目存储                                  │
├─────────────────────────────────────────────────────────────┤
│  context_blob     │  压缩的 JSON (zlib)    │  ~70% 更小      │
│  context_keywords │  用于搜索的索引表      │  O(1) 查找      │
│  emb_summary      │  384 维向量（摘要）    │  语义           │
│  emb_context      │  384 维向量（上下文）  │  语义           │
└─────────────────────────────────────────────────────────────┘
```

结果：**全面的**搜索（不会错过任何东西）加上**速度**（在数千个条目上亚秒级响应）。

</details>

<br>

<details>
<summary><h2>基于科学</h2></summary>

> **TL;DR：** 知识图谱（+20% 准确性）、间隔重复（+6-9% 保留率）、上下文检索（-67% 失败率），全部由同行评审的研究支持。

Rekall 不是一堆直觉的集合——它基于同行评审的认知科学和信息检索研究构建。以下是我们学到的以及如何应用的：

### 知识图谱：+20% 检索准确性

**研究**：关于 RAG 系统中知识图谱的研究表明，连接的信息比孤立的事实更容易检索。

**应用**：Rekall 允许你使用类型化关系（`related`、`supersedes`、`derived_from`、`contradicts`）链接条目。当你搜索时，链接的条目会相互提升分数。当你修复一个新的超时 bug 时，Rekall 会浮现你解决过的其他三个超时问题——以及你从中提取的模式。

### 情景记忆 vs 语义记忆：你的大脑如何组织

**研究**：Tulving（1972）确立了人类记忆有两个不同的系统——情景记忆（特定事件："我在周二修复了这个 bug"）和语义记忆（一般知识："对于外部 API 始终添加重试"）。

**应用**：Rekall 区分 `episodic` 条目（发生了什么）和 `semantic` 条目（你学到了什么）。`generalize` 命令帮助你从情景中提取模式。这反映了专业知识的发展：你积累经验，然后将它们提炼成原则。

### 间隔重复：+6-9% 保留率

**研究**：间隔效应（Ebbinghaus，1885）和 SM-2 算法表明，以递增的间隔复习信息可以显著提高保留率。

**应用**：Rekall 跟踪你访问每个条目的时间并计算整合分数。`review` 命令浮现即将消失的知识。`stale` 命令查找你几个月没碰过的条目——在它们被遗忘之前。

### 上下文检索：-67% 搜索失败

**研究**：Anthropic 的上下文检索论文表明，传统的 RAG 系统失败是因为它们在编码时剥离了上下文。添加 50-100 个 token 的上下文可以将检索失败减少 67%。

**应用**：Rekall 的结构化上下文（情况、解决方案、关键词）在"什么"旁边保留了"为什么"。双重嵌入策略确保聚焦查询和探索性搜索都能找到相关条目。

### 渐进式披露：-98% token 使用

**研究**：Anthropic 的工程博客记录，返回紧凑摘要而不是完整内容可以将 token 使用减少 98%，同时保持任务成功。

**应用**：Rekall 的 MCP 服务器返回紧凑结果（id、标题、分数、片段）并提示获取完整详细信息。你的 AI 助手获得所需内容，而不会耗尽其上下文窗口。

### 整合分数：建模遗忘

**研究**：遗忘曲线表明，没有强化的记忆会呈指数衰减。访问频率和最近性都很重要。

**应用**：Rekall 为每个条目计算整合分数：

```python
score = 0.6 × frequency_factor + 0.4 × freshness_factor
```

你经常且最近访问的条目具有高整合度（稳定知识）。你几个月没碰过的条目具有低整合度（有被遗忘的风险）。

**我们阅读论文，所以你不必。然后我们构建了一个应用它们的工具。**

</details>

<br>

## 了解更多

| 资源 | 描述 |
|----------|-------------|
| [入门指南](docs/getting-started.md) | 安装和第一步 |
| [CLI 参考](docs/usage.md) | 完整的命令文档 |
| [MCP 集成](docs/mcp-integration.md) | 连接到 AI 助手 |
| [架构](docs/architecture.md) | 技术图表和内部结构 |
| [贡献](CONTRIBUTING.md) | 如何贡献 |
| [更新日志](CHANGELOG.md) | 发布历史 |

---

## 要求

- Python 3.9+
- 就这些。没有云服务。没有 API 密钥。没有账户。

---

## 许可证

MIT — 随你怎么用。

---

<p align="center">
<strong>停止丢失知识。开始记住。</strong>
<br><br>

```bash
uv tool install git+https://github.com/guthubrx/rekall.git
rekall
```
</p>
