# Rekall

```
        ██████╗ ███████╗██╗  ██╗ █████╗ ██╗     ██╗
        ██╔══██╗██╔════╝██║ ██╔╝██╔══██╗██║     ██║
        ██████╔╝█████╗  █████╔╝ ███████║██║     ██║
        ██╔══██╗██╔══╝  ██╔═██╗ ██╔══██║██║     ██║
        ██║  ██║███████╗██║  ██╗██║  ██║███████╗███████╗
        ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝╚══════╝
```

<p align="center">
  <img src="https://img.shields.io/badge/100%25-Local-blue?style=flat-square" alt="100% Local">
  <img src="https://img.shields.io/badge/No_API_Keys-green?style=flat-square" alt="No API Keys">
  <img src="https://img.shields.io/badge/MCP-Compatible-purple?style=flat-square" alt="MCP Compatible">
  <img src="https://img.shields.io/badge/Python-3.9+-yellow?style=flat-square" alt="Python 3.9+">
</p>

> *"Get your ass to Mars. Quaid... crush those bugs"*

**翻译：** [English](README.md) | [Français](README.fr.md) | [Español](README.es.md) | [Deutsch](README.de.md)

---

### TL;DR

**问题：** 每个开发者都解决过同样的bug两次。不是因为疏忽——而是因为我们是人类，人类会遗忘。研究表明，财富500强公司每年因从未记录的知识损失315亿美元。

**我们的方法：** Rekall是一个基于认知科学研究构建的个人知识库。我们研究了人类记忆实际如何工作——情节记忆vs语义记忆、间隔重复、知识图谱——并将其应用于开发者工作流。

**它做什么：** 在工作中捕获bug、模式、决策、配置。按意义搜索，不仅是关键词——Rekall使用可选的本地嵌入（EmbeddingGemma）结合全文搜索来查找相关条目，即使你的词语不完全匹配。存储丰富的上下文（情况、解决方案、什么失败了）以便稍后消除类似问题的歧义。

**与你的工具兼容：** Rekall公开一个MCP服务器，兼容大多数AI驱动的开发工具——Claude Code、Claude Desktop、Cursor、Windsurf、Continue.dev以及任何MCP客户端。一条命令（`rekall mcp`），你的AI就会在每次修复前查阅你的知识。

**它自动化什么：** 关键词提取、巩固评分、模式检测、链接建议、复习计划（SM-2间隔重复）。你专注于捕获——Rekall处理其余的事情。

```bash
# 安装
uv tool install git+https://github.com/guthubrx/rekall.git

# 捕获（交互模式引导你）
rekall add bug "Safari上CORS失败" --context-interactive

# 搜索（理解意义，不仅是关键词）
rekall search "浏览器阻止API"

# 连接你的AI（一条命令，适用于Claude/Cursor/Windsurf）
rekall mcp
```

---

<br>

## 你已经解决过这个问题了。

三个月前，你花了两个小时调试一个神秘的错误。你找到了解决方案。然后继续前进。

今天，同样的错误出现了。你盯着它看。它看起来很熟悉。但那个解决方案在哪里？

你从头开始。又浪费了两个小时。

**每个开发者都会遇到这种情况。** 根据研究，财富500强公司每年损失315亿美元，因为学到的经验从未被记录下来。不是因为疏忽——而是因为我们是人类，人类会遗忘。

---

## 如果你的AI助手能替你记住呢？

想象一下：你让Claude或Cursor修复一个bug。在写任何代码之前，它先检查你的个人知识库：

```
🔍 搜索你的知识...

找到2个相关条目：

[1] bug: Safari上的CORS错误 (85%匹配)
    "添加 credentials: include 和正确的 Access-Control 头"
    → 你3个月前解决过这个

[2] pattern: 跨域请求处理 (72%匹配)
    "总是在Safari上测试 - 它对CORS更严格"
    → 从4个类似bug中提取的模式
```

你的AI助手现在有了上下文。它知道什么以前有效。它不会重新发明轮子——它会在你过去的经验上构建。

**这就是Rekall。**

<p align="center">
  <img src="docs/screenshots/demo.gif" alt="Rekall 演示" width="700">
</p>

---

## 一个像你一样思考的第二大脑

Rekall不仅仅是一个笔记应用。它基于人类记忆实际运作的方式构建：

### 你的知识，相互连接

当你解决某件事时，相关知识会自动浮现。修复了一个超时bug？Rekall会向你展示你解决过的另外三个超时问题，以及你从中提取的重试模式。

```
              ┌──────────────┐
              │  Auth超时    │
              │   (今天)     │
              └──────┬───────┘
                     │ 类似于...
        ┌────────────┼────────────┐
        ▼            ▼            ▼
  ┌──────────┐ ┌──────────┐ ┌──────────┐
  │ DB #47   │ │ API #52  │ │ Cache #61│
  │ (2周前)  │ │ (1个月前)│ │ (3个月前)│
  └────┬─────┘ └────┬─────┘ └──────────┘
       └──────┬─────┘
              ▼
     ┌─────────────────┐
     │ 模式：带回退    │
     │ 的重试          │
     └─────────────────┘
```

### 事件变成智慧

你修复的每个bug都是一个**情节**——一个有上下文的特定事件。但模式会出现。在修复三个类似的超时bug后，Rekall帮助你提取**原则**："外部API总是添加指数回退重试。"

情节是原材料。模式是可重用的知识。

### 被遗忘的知识重新浮现

Rekall追踪你访问什么以及何时访问。几个月没碰过的知识？它会在完全消失之前提醒你。把它想象成给你的开发者大脑的间隔重复。

---

## 实际操作

### 1. 工作时捕获知识

解决了棘手的问题后，用10秒钟记录下来：

```bash
rekall add bug "Safari上CORS失败" --context-interactive
```

Rekall会问：*发生了什么？什么修复了它？什么关键词应该触发这个？*

```
> 情况：Safari即使设置了CORS头也阻止请求
> 解决方案：添加 credentials: 'include' 和显式 Allow-Origin
> 关键词：cors, safari, cross-origin, fetch, credentials
```

完成。未来的你会感谢你。

### 2. 按意义搜索，不只是关键词

不记得你是叫它"CORS"还是"跨域"了？没关系。

```bash
rekall search "浏览器阻止我的API调用"
```

Rekall理解意义。即使你的词不完全匹配，它也能找到相关条目。

### 3. 让你的AI助手使用它

将Rekall连接到Claude、Cursor或任何支持MCP的AI：

```bash
rekall mcp  # 启动服务器
```

现在你的AI在每次修复前都会查阅你的知识。它引用你过去的解决方案。它建议保存新的。你的知识随时间积累。

---

## 界面

### 终端UI
```bash
rekall  # 启动可视界面
```

```
┌─ Rekall ────────────────────────────────────────────────┐
│  🔍 搜索: cors safari                                   │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  [1] bug: Safari上CORS失败                 85% ██████   │
│      safari, cors, fetch  •  3个月前                    │
│      "添加 credentials: include..."                     │
│                                                         │
│  [2] pattern: 跨域处理                     72% █████    │
│      架构  •  1个月前                                   │
│      "Safari对CORS更严格"                               │
│                                                         │
├─────────────────────────────────────────────────────────┤
│  [/] 搜索  [a] 添加  [Enter] 查看  [q] 退出             │
└─────────────────────────────────────────────────────────┘
```

### 命令行
```bash
rekall add bug "修复: auth中的空指针" -t auth,null
rekall search "认证错误"
rekall show 01HX7...
rekall link 01HX7 01HY2 --type related
rekall review  # 间隔重复会话
```

<br>

## Rekall为你做什么

> **理念：** 你专注于捕获你的知识。Rekall处理其他一切。

### 每添加一个条目

- **关键词提取** — 分析你的标题和内容，建议相关关键词
- **上下文验证** — 如果情况/解决方案太模糊或笼统则警告
- **嵌入生成** — 创建语义向量用于智能搜索（如果启用）
- **自动索引** — 全文搜索索引实时更新

### 每次搜索

- **混合匹配** — 组合精确词（FTS5）+意义（嵌入）+触发器（关键词）
- **零配置** — 开箱即用，不需要调优
- **关联条目** — 自动显示相关知识

### 后台运行（你什么都不用做）

- **访问追踪** — 每次查询更新频率和新近度统计
- **巩固分数** — 计算每个记忆有多"稳定"（60%频率+40%新鲜度）
- **模式检测** — 找到相似条目的聚类，建议创建模式
- **链接建议** — 检测相关条目，建议连接
- **复习计划** — SM-2算法安排最佳复习时间（间隔重复）
- **上下文压缩** — 以70-85%更小的尺寸存储冗长的上下文

### 当你运行`rekall review`时

- **加载到期条目** — 基于SM-2计划，不是任意日期
- **调整难度** — 你的评分（0-5）自动更新容易因子
- **重新计划** — 计算下一个最佳复习日期

---

## 你可以捕获什么？

| 类型 | 用于 | 示例 |
|------|------|------|
| `bug` | 解决的问题 | "Safari CORS与credentials" |
| `pattern` | 可重用的方法 | "带指数回退的重试" |
| `decision` | 为什么选X而不是Y | "这个项目用PostgreSQL而不是MongoDB" |
| `pitfall` | 要避免的错误 | "生产环境永远不要SELECT *" |
| `config` | 有效的配置 | "VS Code Python调试配置" |
| `reference` | 有用的文档/链接 | "那个StackOverflow答案" |
| `snippet` | 值得保留的代码 | "通用防抖函数" |
| `til` | 快速学习 | "Git rebase -i可以重新排序提交" |

---

## 100%本地。100%属于你。

```
你的机器
     │
     ▼
┌─────────────────────────────────────┐
│  ~/.local/share/rekall/             │
│                                     │
│  一切都留在这里。                    │
│  没有云。没有账户。没有追踪。        │
│                                     │
└─────────────────────────────────────┘
     │
     ▼
  不会去别的地方。永远不会。
```

你的知识属于你。Rekall不会打电话回家。它不需要账户。它可以离线工作。你的调试历史、你的架构决策、你辛苦获得的智慧——全部私密，全部本地。

---

## 开始使用

### 安装

```bash
# 使用 uv（推荐）
uv tool install git+https://github.com/guthubrx/rekall.git

# 使用 pipx
pipx install git+https://github.com/guthubrx/rekall.git
```

### 试试看

```bash
# 添加你的第一个条目
rekall add bug "我的第一个捕获的bug" -t test

# 搜索它
rekall search "第一个"

# 打开可视界面
rekall
```

---

## MCP服务器：兼容任何AI助手

Rekall通过 **Model Context Protocol (MCP)** 暴露你的知识库——这是连接AI助手与外部工具的开放标准。

### 一条命令，通用访问

```bash
rekall mcp  # 启动MCP服务器
```

### 兼容主流AI工具

| 工具 | 状态 | 配置 |
|------|------|------|
| **Claude Code** | ✅ 原生 | 自动检测 |
| **Claude Desktop** | ✅ 原生 | 添加到 `claude_desktop_config.json` |
| **Cursor** | ✅ 支持 | MCP设置 |
| **Windsurf** | ✅ 支持 | MCP设置 |
| **Continue.dev** | ✅ 支持 | MCP配置 |
| **任何MCP客户端** | ✅ 兼容 | 标准MCP协议 |

### 配置示例 (Claude Desktop)

添加到你的 `claude_desktop_config.json`：

```json
{
  "mcpServers": {
    "rekall": {
      "command": "rekall",
      "args": ["mcp"]
    }
  }
}
```

### 你的AI能做什么

连接后，你的AI助手可以：

- **搜索** 回答前先查询你的知识库
- **引用** 在回复中引用你过去的解决方案
- **建议** 解决问题后建议捕获新知识
- **关联** 自动链接相关条目
- **呈现** 你调试历史中的模式

你的知识自动积累——用得越多，它就越智能。

---

## 与Speckit集成

[Speckit](https://github.com/YOUR_USERNAME/speckit) 是一个规范驱动的开发工具包。与Rekall结合，它创建了一个强大的工作流，让你的规范为知识库提供养分。

### 为什么要集成？

- **规范变成可搜索的知识**：编写规范时做出的决策被捕获
- **模式涌现**：跨项目的通用架构选择会浮现
- **上下文被保留**：规范背后的"为什么"永远不会丢失

### 安装

1. 安装两个工具：
```bash
uv tool install git+https://github.com/guthubrx/rekall.git
uv tool install git+https://github.com/YOUR_USERNAME/speckit.git
```

2. 配置Speckit使用Rekall（在你的 `.speckit/config.yaml` 中）：
```yaml
integrations:
  rekall:
    enabled: true
    auto_capture: true  # 自动捕获决策
    types:
      - decision
      - pattern
      - pitfall
```

3. 在规范工作期间，Speckit会：
   - 查询Rekall获取相关的过去决策
   - 建议捕获新的架构选择
   - 将规范与相关知识条目关联

### 工作流示例

```bash
# 开始指定一个功能
speckit specify "用户认证系统"

# Speckit查询Rekall："你之前做过认证决策吗？"
# → 显示你另一个项目中的OAuth vs JWT决策

# 完成规范后
speckit plan

# Rekall捕获：decision "微服务中使用JWT进行无状态认证"
```

<br>

<details>
<summary><h2>底层原理：搜索如何工作</h2></summary>

> **TL;DR:** 混合搜索结合FTS5（50%）+语义嵌入（30%）+关键词（20%）。可选本地模型，无API密钥。

Rekall不仅仅是关键词匹配。它理解你的意思。

### 简单搜索的问题

你记录了一个bug："Safari上的CORS错误。"后来，你搜索"浏览器阻止我的API调用"。简单的关键词搜索什么都找不到——词语不匹配。

### 混合搜索：既全面又快速

Rekall结合三种搜索策略：

```
┌──────────────────────────────────────────────────────────────┐
│                     你的查询                                  │
│              "浏览器阻止API调用"                              │
└──────────────────────────────────┬───────────────────────────┘
                                   │
           ┌───────────────────────┼───────────────────────┐
           ▼                       ▼                       ▼
    ┌─────────────┐        ┌─────────────┐        ┌─────────────┐
    │   FTS5      │        │   语义      │        │  关键词     │
    │  (50%)      │        │   (30%)     │        │   (20%)     │
    │             │        │             │        │             │
    │ 精确词语    │        │ 通过向量    │        │ 结构化      │
    │ 匹配        │        │ 理解含义    │        │ 触发器      │
    └──────┬──────┘        └──────┬──────┘        └──────┬──────┘
           │                      │                      │
           └───────────────────────┼───────────────────────┘
                                   ▼
                        ┌─────────────────┐
                        │   最终得分      │
                        │   85% 匹配      │
                        └─────────────────┘
```

- **全文搜索 (50%)**：SQLite FTS5找到精确和部分匹配
- **语义搜索 (30%)**：向量嵌入找到概念相似的内容——"浏览器"匹配"Safari"，"阻止"匹配"CORS错误"
- **关键词索引 (20%)**：你的结构化上下文关键词提供明确的触发器

### 本地嵌入：可选但强大

语义搜索是**可选的**。Rekall仅使用FTS5全文搜索就能完美运行——不需要模型。

但如果你想要语义理解，Rekall使用 **EmbeddingGemma**（3.08亿参数），一个完全在你机器上运行的最先进嵌入模型：

- **100%本地**：没有数据离开你的电脑，没有API密钥，没有云
- **多语言**：支持100+种语言
- **快速**：标准笔记本CPU上每次嵌入约500毫秒
- **轻量**：int8量化下约200MB内存

```bash
# 仅FTS模式（默认，不需要模型）
rekall search "CORS错误"

# 启用语义搜索（首次使用时下载模型）
rekall config set embeddings.enabled true
```

### 双重嵌入：上下文很重要

当你记录知识时，Rekall存储两个嵌入：

1. **摘要嵌入**：标题+内容+标签——用于聚焦搜索
2. **上下文嵌入**：完整的情况/解决方案——用于探索性搜索

这解决了检索中的一个根本问题：摘要会丢失上下文。如果你搜索"Safari堆栈跟踪"，摘要"修复CORS"不会匹配——但你记录的完整上下文（提到了堆栈跟踪）会匹配。

### 结构化上下文：消除歧义

你修复了5个不同的"超时"bug。以后怎么找到正确的那个？仅靠关键词没用——它们都标记为"超时"。

Rekall为每个条目捕获**结构化上下文**：

```
┌─────────────────────────────────────────────────────────────┐
│  situation        │  "部署后API调用超时"                     │
│  solution         │  "增加了连接池大小"                       │
│  what_failed      │  "重试逻辑没有帮助"                       │
│  trigger_keywords │  ["超时", "部署", "连接池"]               │
│  error_messages   │  "30秒后ETIMEDOUT"                       │
│  files_modified   │  ["config/database.yml"]                 │
└─────────────────────────────────────────────────────────────┘
```

搜索时，Rekall使用这个上下文来消除歧义：

- **"部署后超时"** → 找到连接池bug（匹配情况）
- **"ETIMEDOUT"** → 找到有这个确切错误消息的条目
- **"重试没用"** → 找到尝试过重试但失败的条目

`--context-interactive`标志引导你捕获这些：

```bash
rekall add bug "生产环境超时" --context-interactive
# Rekall问：发生了什么？什么修复了它？什么没用？
# 你的回答变成可搜索的消歧上下文
```

### 压缩存储

上下文可能很冗长。Rekall用zlib压缩结构化上下文，并维护单独的关键词索引用于快速搜索：

```
┌─────────────────────────────────────────────────────────────┐
│                    条目存储                                  │
├─────────────────────────────────────────────────────────────┤
│  context_blob     │  压缩JSON (zlib)        │  缩小约70%   │
│  context_keywords │  索引表                 │  O(1)查找    │
│  emb_summary      │  768维向量              │  语义        │
│  emb_context      │  768维向量              │  语义        │
└─────────────────────────────────────────────────────────────┘
```

结果：**全面**搜索（不遗漏任何内容）同时保持**速度**（数千条目亚秒级响应）。

</details>

<br>

<details>
<summary><h2>基于科学</h2></summary>

Rekall不是一堆猜测——它基于同行评审的认知科学和信息检索研究构建。以下是我们学到的以及如何应用：

### 知识图谱：+20%检索准确率

**研究**：RAG系统中知识图谱的研究表明，连接的信息比孤立的事实更容易检索。

**应用**：Rekall让你用类型化关系连接条目（`related`、`supersedes`、`derived_from`、`contradicts`）。搜索时，连接的条目相互提升分数。当你修复一个新的超时bug时，Rekall会显示你解决过的其他三个超时问题——以及你从中提取的模式。

### 情节记忆vs语义记忆：你的大脑如何组织

**研究**：Tulving（1972）确立了人类记忆有两个不同的系统——情节性（特定事件："我周二修复了这个bug"）和语义性（一般知识："外部API总是添加重试"）。

**应用**：Rekall区分`episodic`条目（发生了什么）和`semantic`条目（学到了什么）。`generalize`命令帮助你从情节中提取模式。这反映了专业知识如何发展：你积累经验，然后将它们提炼成原则。

### 间隔重复：+6-9%记忆保持率

**研究**：间隔效应（Ebbinghaus，1885）和SM-2算法表明，以递增间隔复习信息可以显著提高记忆保持率。

**应用**：Rekall追踪你何时访问每个条目并计算巩固分数。`review`命令显示即将消退的知识。`stale`命令找到你几个月没碰过的条目——在它们被遗忘之前。

### 上下文检索：-67%搜索失败

**研究**：Anthropic的上下文检索论文表明，传统RAG系统失败是因为它们在编码时去除了上下文。添加50-100个token的上下文可以减少67%的检索失败。

**应用**：Rekall的结构化上下文（情况、解决方案、关键词）在"什么"旁边保留了"为什么"。双重嵌入策略确保聚焦查询和探索性搜索都能找到相关条目。

### 渐进式披露：-98%token使用

**研究**：Anthropic的工程博客记录了返回紧凑摘要而不是完整内容可以减少98%的token使用，同时保持任务成功。

**应用**：Rekall的MCP服务器返回紧凑结果（id、标题、分数、摘要），并提示获取完整详情。你的AI助手得到它需要的，而不会爆掉它的上下文窗口。

### 巩固分数：建模遗忘

**研究**：遗忘曲线表明，没有强化的记忆会指数衰减。访问频率和新近度都很重要。

**应用**：Rekall为每个条目计算巩固分数：

```python
score = 0.6 × 频率因子 + 0.4 × 新鲜度因子
```

你经常且最近访问的条目具有高巩固度（稳定知识）。你几个月没碰过的条目具有低巩固度（有被遗忘的风险）。

---

**我们读了论文，所以你不必读。然后我们构建了一个应用它们的工具。**

</details>

<br>

---

## 了解更多

| 资源 | 描述 |
|------|------|
| `rekall --help` | 完整命令参考 |
| `rekall version` | 版本和数据库信息 |
| `rekall changelog` | 最新更新 |
| [CHANGELOG.md](CHANGELOG.md) | 详细版本历史 |

---

## 要求

- Python 3.9+
- 就这些。没有云服务。没有API密钥。没有账户。

---

## 许可证

MIT——随你怎么用。

---

<p align="center">
<strong>停止丢失知识。开始记忆。</strong>
<br><br>

```bash
uv tool install git+https://github.com/guthubrx/rekall.git
rekall
```
</p>
